# user_bot.py
import re
import random
import asyncio
from pathlib import Path
from difflib import SequenceMatcher

import pandas as pd
import aiosqlite
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command, CommandStart
from aiogram.filters.state import StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile
from aiogram.exceptions import TelegramNetworkError

# --------------------
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
# --------------------
API_TOKEN       = "7916603610:AAFc4MEz4SKhe-kUlWHGA3l5fnCxQClIuac"
BASE_DIR        = Path(__file__).resolve().parent

# –ü–æ–∏—Å–∫ Excel-—Ñ–∞–π–ª–∞ —Å–æ —Å–ø–∏—Å–∫–æ–º –ø—Ä–æ—Ñ–µ—Å—Å–∏–π –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞
excel_files     = list(BASE_DIR.glob("*.xlsx"))
if not excel_files:
    raise FileNotFoundError("Excel-—Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º –ø—Ä–æ—Ñ–µ—Å—Å–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞")
EXCEL_PATH      = excel_files[0]
WAIT_VIDEO_PATH = BASE_DIR / "waiting_video.mp4"

# –ö–∞–Ω–∞–ª—ã –∏ –∞–¥–º–∏–Ω—ã
SUB_CHANNEL_USERNAME   = "@test11111111223084034"  # –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏
ADMIN_CHANNEL_USERNAME = "@test11111111223084034"  # –∞–¥–º–∏–Ω-–∫–∞–Ω–∞–ª –¥–ª—è HELP –∏ –∫–æ–º–∞–Ω–¥
ADMIN_CHAT_ID          = None                        # numeric chat_id –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
ADMIN_IDS              = [434092620, 386406595]      # —Å–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ user_id

# --------------------
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
# --------------------
bot = Bot(token=API_TOKEN)
dp  = Dispatcher()

# –•—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ file_id —Ñ–æ—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
best_file_id: dict[int, str] = {}

# --------------------
# FSM States
# --------------------
class Form(StatesGroup):
    check_sub      = State()
    ask_name       = State()
    ask_profession = State()
    ask_photo      = State()

# --------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# --------------------

def normalize(text: str) -> str:
    t = text.lower()
    t = re.sub(r"[^\w\s]", "", t)
    return re.sub(r"\s+", " ", t).strip()

# --------------------
# –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏–π –∏–∑ Excel
# --------------------
df = pd.read_excel(EXCEL_PATH, sheet_name="–õ–∏—Å—Ç1")
raw_professions = df.iloc[3:,0].dropna().astype(str).tolist()
professions = [normalize(p) for p in raw_professions]

# --------------------
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
# --------------------
async def init_db():
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        await db.execute(
            """
            CREATE TABLE IF NOT EXISTS users (
                user_id     INTEGER PRIMARY KEY,
                name        TEXT,
                profession  TEXT,
                photo_count INTEGER DEFAULT 0
            );
            """
        )
        await db.commit()

async def get_user(uid: int):
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id = ?", (uid,))
        return await cur.fetchone()

async def upsert_user(uid: int, name=None, profession=None, inc_photo=False):
    user = await get_user(uid)
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        if user:
            if name:
                await db.execute("UPDATE users SET name = ? WHERE user_id = ?", (name, uid))
            if profession:
                await db.execute("UPDATE users SET profession = ? WHERE user_id = ?", (profession, uid))
            if inc_photo:
                await db.execute("UPDATE users SET photo_count = photo_count + 1 WHERE user_id = ?", (uid,))
        else:
            await db.execute(
                "INSERT INTO users (user_id, name, profession, photo_count) VALUES (?, ?, ?, ?)",
                (uid, name or "", profession or "", 1 if inc_photo else 0)
            )
        await db.commit()

# --------------------
# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
# --------------------

def sub_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å", callback_data="check_sub"),
        InlineKeyboardButton(text="üîó –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=f"https://t.me/{SUB_CHANNEL_USERNAME.lstrip('@')}" )
    ]])

def retry_prof_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="üé≤ –°–ª—É—á–∞–π–Ω–∞—è –ø—Ä–æ—Ñ–µ—Å—Å–∏—è", callback_data="random_profession")
    ]])

def result_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="–ü–æ–º–æ—â—å", callback_data="help"),
        InlineKeyboardButton(text="–î—Ä—É–≥—É—é —Ñ–∏–≥—É—Ä–∫—É", callback_data="another")
    ]])

# --------------------
# –•—ç–Ω–¥–ª–µ—Ä—ã
# --------------------
@dp.startup()
async def on_startup():
    global ADMIN_CHAT_ID
    await init_db()
    chat = await bot.get_chat(ADMIN_CHANNEL_USERNAME)
    ADMIN_CHAT_ID = chat.id

@dp.message(CommandStart())
async def cmd_start(msg: types.Message, state: FSMContext):
    await msg.answer(
        f"–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∞–≤–∞—Ç–∞—Ä–∫—É, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ {SUB_CHANNEL_USERNAME}",
        reply_markup=sub_keyboard()
    )
    await state.set_state(Form.check_sub)

@dp.callback_query(StateFilter(Form.check_sub), F.data == "check_sub")
async def check_sub(call: types.CallbackQuery, state: FSMContext):
    try:
        m = await bot.get_chat_member(SUB_CHANNEL_USERNAME, call.from_user.id)
        ok = m.status in ("creator", "administrator", "member")
    except:
        ok = False
    if ok:
        await call.message.edit_text("–ù–∞–ø–∏—à–∏—Ç–µ, –∫–∞–∫ –≤–∞—Å –∑–æ–≤—É—Ç. –õ—É—á—à–µ –æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –∏–º—è...")
        await state.set_state(Form.ask_name)
    else:
        await call.message.edit_text(
            f"–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ {SUB_CHANNEL_USERNAME}",
            reply_markup=sub_keyboard()
        )

@dp.message(StateFilter(Form.ask_name))
async def process_name(msg: types.Message, state: FSMContext):
    await upsert_user(msg.from_user.id, name=msg.text.strip())
    await msg.answer("–£–∫–∞–∂–∏—Ç–µ –≤–∞—à—É –ø—Ä–æ—Ñ–µ—Å—Å–∏—é")
    await state.set_state(Form.ask_profession)

@dp.message(StateFilter(Form.ask_profession))
async def process_profession(msg: types.Message, state: FSMContext):
    text = normalize(msg.text)
    best, score = None, 0.0
    for p in professions:
        s = SequenceMatcher(None, text, p).ratio()
        if s > score:
            best, score = p, s
    if score >= 0.75:
        await upsert_user(msg.from_user.id, profession=best)
        await msg.answer("–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ñ–∏–≥—É—Ä–∫—É, –ø—Ä–∏—à–ª–∏—Ç–µ —Å–≤–æ–µ —Ñ–æ—Ç–æ –≤ —á–∞—Ç")
        await state.set_state(Form.ask_photo)
    else:
        await msg.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –ø—Ä–æ—Ñ–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞...", reply_markup=retry_prof_keyboard())

@dp.callback_query(F.data == "random_profession")
async def random_prof(call: types.CallbackQuery, state: FSMContext):
    prof = random.choice(professions)
    await upsert_user(call.from_user.id, profession=prof)
    await call.message.edit_text(f"–í–∞—à–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏—è ‚Äî {prof}\n–ü—Ä–∏—à–ª–∏—Ç–µ —Å–≤–æ–µ —Ñ–æ—Ç–æ –¥–ª—è —Ñ–∏–≥—É—Ä–∫–∏")
    await state.set_state(Form.ask_photo)

@dp.message(StateFilter(Form.ask_photo), ~F.photo)
async def not_photo(msg: types.Message):
    await msg.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ –≤ –º–µ–¥–∏–∞-—Ñ–æ—Ä–º–∞—Ç–µ")

@dp.message(StateFilter(Form.ask_photo), F.photo)
async def process_photo(msg: types.Message, state: FSMContext):
    user = await get_user(msg.from_user.id)
    if user and user[3] >= 2:
        await msg.answer("–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞ —Ñ–æ—Ç–æ (2)")
        return
    await upsert_user(msg.from_user.id, inc_photo=True)
    await msg.answer("–°–æ–∑–¥–∞–µ–º –≤–∞—à—É —Ñ–∏–≥—É—Ä–∫—É... –≠—Ç–æ –∑–∞–π–º–µ—Ç –¥–æ –º–∏–Ω—É—Ç—ã")
    try:
        await msg.answer_video(FSInputFile(str(WAIT_VIDEO_PATH)), caption="–ñ–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ...")
    except TelegramNetworkError:
        pass
    fid = msg.photo[-1].file_id
    best_file_id[msg.from_user.id] = fid
    await msg.answer_photo(photo=fid, caption="–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!", reply_markup=result_keyboard())
    await state.clear()

@dp.callback_query(F.data == "help")
async def help_req(call: types.CallbackQuery):
    uid = call.from_user.id
    await bot.forward_message(chat_id=ADMIN_CHAT_ID, from_chat_id=call.message.chat.id, message_id=call.message.message_id)
    await bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"HELP –∑–∞–ø—Ä–æ—Å –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid}")
    await call.answer("–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω-—á–∞—Ç", show_alert=True)

@dp.callback_query(F.data == "another")
async def another_fun(call: types.CallbackQuery, state: FSMContext):
    await call.message.answer("–ü—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ –¥–ª—è —Ñ–∏–≥—É—Ä–∫–∏")
    await state.set_state(Form.ask_photo)

# --------------------
# –ê–¥–º–∏–Ω—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã (–æ—Ç –±–æ—Ç–∞)
# --------------------
@dp.message(Command("broadcast"))
async def admin_broadcast(msg: types.Message):
    if msg.from_user.id not in ADMIN_IDS:
        return
    parts = msg.text.split(' ', 1)
    if len(parts) < 2:
        return await msg.reply("‚ùå –£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç: /broadcast <—Ç–µ–∫—Å—Ç>")
    text = parts[1]
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        cur = await db.execute("SELECT user_id FROM users")
        ids = [r[0] for r in await cur.fetchall()]
    success = 0
    for uid in ids:
        try:
            await bot.send_message(chat_id=uid, text=text)
            success += 1
        except Exception:
            pass
    await msg.reply(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: {success} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

@dp.message(Command("send"))
async def admin_send(msg: types.Message):
    if msg.from_user.id not in ADMIN_IDS:
        return
    parts = msg.text.split(' ', 2)
    if len(parts) < 3:
        return await msg.reply("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /send <user_id> <—Ç–µ–∫—Å—Ç>")
    try:
        uid = int(parts[1])
    except ValueError:
        return await msg.reply("‚ùå User ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    text = parts[2]
    try:
        await bot.send_message(chat_id=uid, text=text)
        await msg.reply(f"‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {uid}.")
    except Exception as e:
        await msg.reply(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: {e}")

@dp.message(Command("reset"))
async def admin_reset(msg: types.Message):
    if msg.from_user.id not in ADMIN_IDS:
        return
    parts = msg.text.split(' ', 1)
    if len(parts) < 2:
        return await msg.reply("‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /reset <user_id>")
    try:
        uid = int(parts[1])
    except ValueError:
        return await msg.reply("‚ùå User ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        await db.execute("UPDATE users SET photo_count = 0 WHERE user_id = ?", (uid,))
        await db.commit()
    await msg.reply(f"‚úÖ –°—á–µ—Ç—á–∏–∫ —Ñ–æ—Ç–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} —Å–±—Ä–æ—à–µ–Ω.")

# --------------------
# –ê–¥–º–∏–Ω—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã (–∏–∑ –∫–∞–Ω–∞–ª–∞)
# --------------------
@dp.channel_post(Command("broadcast"))
async def channel_broadcast(post: types.Message):
    if post.chat.id != ADMIN_CHAT_ID:
        return
    parts = post.text.split(' ', 1)
    if len(parts) < 2:
        return
    text = parts[1]
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        cur = await db.execute("SELECT user_id FROM users")
        ids = [r[0] for r in await cur.fetchall()]
    for uid in ids:
        try:
            await bot.send_message(chat_id=uid, text=text)
        except Exception:
            pass

@dp.channel_post(Command("send"))
async def channel_send(post: types.Message):
    if post.chat.id != ADMIN_CHAT_ID:
        return
    parts = post.text.split(' ', 2)
    if len(parts) < 3:
        return
    try:
        uid = int(parts[1])
    except ValueError:
        return
    text = parts[2]
    try:
        await bot.send_message(chat_id=uid, text=text)
    except Exception:
        pass

@dp.channel_post(Command("reset"))
async def channel_reset(post: types.Message):
    if post.chat.id != ADMIN_CHAT_ID:
        return
    parts = post.text.split(' ', 1)
    if len(parts) < 2:
        return
    try:
        uid = int(parts[1])
    except ValueError:
        return
    async with aiosqlite.connect(BASE_DIR / "users.db") as db:
        await db.execute("UPDATE users SET photo_count = 0 WHERE user_id = ?", (uid,))
        await db.commit()

# --------------------
# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
# --------------------
if __name__ == "__main__":
    dp.run_polling(bot, skip_updates=True)
